---
description: Comprehensive Rust development guidelines for database implementation
globs: ["**/*.rs", "**/*.md", "Cargo.toml", "Cargo.lock"]
alwaysApply: true
---

# Comprehensive Rust Development Guidelines

## Project Context
You are an expert in database engine design and implementation using Rust.

## Session Initialization
- Read and analyze the entire codebase.
- Review README.md and all documentation in the `doc/` directory.
- Index project structure before making changes.

## Code Style & Formatting
- Follow Rust edition 2024 style standards.
- Use `snake_case` for variables/functions, `PascalCase` for types/traits.
- Run `cargo fmt` after code changes before running the final build/test of a response.
- Maintain clippy-clean code (zero warnings).
- Minimize use of lint suppression attributes such as `#[allow(unused)]`; address the underlying issue instead. Use only when genuinely necessary.
- Import types with `use` statements at file top; avoid qualified references in code.
  - When name conflicts occur, use one-level qualification or rename imports

## Error Handling
- Always use `Result<T, E>` over panicking or unwrapping.
- Use `anyhow::Result` for error propagation.
- Use `thiserror` for custom error types instead of formatted strings.

## Documentation
- Document all public APIs with `///` doc comments.
- Include usage examples in rustdoc where appropriate.
- Usage examples must be self-contained, compilable, and simple, using `asserts` to prove outcomes.
- Avoid examples requiring file I/O or network access.
- Check existing tests before adding rustdoc examples to prevent duplication.
- Never use meta-comments like `// Added this field` - code should be self-documenting.

## Testing
- Write unit tests for all public functions, and for private functions as it makes sense, using `#[cfg(test)]` modules in the source file.
- Each unit test must test exactly one call to the function being tested.
- Integration tests should be placed in `tests/` directory, which belongs next to and not in the `src/` directory.
- Review existing tests and avoid scenario duplication.
- Run `cargo test` before completing tasks.
- Use `cargo bench` for performance-critical code, with benchmark tests in `bench/`.
- Use cargo's `tarpaulin` for code coverage, with the output directed to `coverage/`.

## Dependencies
- Keep dependencies minimal and well-justified.
- Use specific version constraints in Cargo.toml.
- Prefer `cargo add [crate]` or `cargo add [crate] -F feature` over directly editing Cargo.toml.
- Prefer established crates from crates.io.

## Coding Guidelines
- Always look for existing code in the codebase that would achieve your goal before writing new code, to avoid duplication.
- Prefer borrowing (`&T`) over cloning.
- Use `&str` over `String` for function parameters.
- Consider memory layout and allocation patterns when creating structures or other objects.

## Build Process
- Always run `cargo build` after code changes.
- Fix all compiler warnings and errors before task completion.
- Verify compilation success before submitting changes.

## Code Quality Principles
- Avoid nesting control structures more than 3 levels, and then only if strictly needed. Use testable functions where needed, instead.
- **DRY**: Extract repeated code into reusable functions.
- Explain Rust-specific patterns (ownership, borrowing, lifetimes) when suggesting code.
- Emphasize safety guarantees in explanations.
